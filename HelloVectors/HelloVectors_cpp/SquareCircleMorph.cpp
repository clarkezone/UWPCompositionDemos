//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "pch.h"
#include "SquareCircleMorph.h"
#include "d2d1.h"
#include <d2d1_1.h>
#include <d2d1helper.h>

#include <Windows.Graphics.Interop.h>

using namespace winrt;
using namespace Windows::UI::Composition;
using namespace Windows::Graphics;

namespace
{
	class GeoSource final :
		public ABI::Windows::Graphics::IGeometrySource2D,
		public ABI::Windows::Graphics::IGeometrySource2DInterop
	{
		ULONG _cRef;
		com_ptr<ID2D1Geometry> _cpGeometry;

	public:
		GeoSource(com_ptr<ID2D1Geometry> pGeometry)
			: _cRef(1)
			, _cpGeometry(pGeometry)
		{ }

		IFACEMETHODIMP QueryInterface(REFIID iid, void ** ppvObject) override
		{
			if (iid == __uuidof(ABI::Windows::Graphics::IGeometrySource2DInterop))
			{
				AddRef();
				*ppvObject = static_cast<ABI::Windows::Graphics::IGeometrySource2DInterop*>(this);
				return S_OK;
			}
			else if (iid == __uuidof(ABI::Windows::Graphics::IGeometrySource2D))
			{
				AddRef();
				*ppvObject = static_cast<ABI::Windows::Graphics::IGeometrySource2D*>(this);
				return S_OK;
			}
			return E_NOINTERFACE;
		}

		IFACEMETHODIMP_(ULONG) AddRef() override
		{
			return InterlockedIncrement(&_cRef);
		}

		IFACEMETHODIMP_(ULONG) Release() override
		{
			ULONG cRef = InterlockedDecrement(&_cRef);
			if (cRef == 0)
			{
				delete this;
			}
			return cRef;
		}

		IFACEMETHODIMP GetIids(ULONG*, IID**) override
		{
			return E_NOTIMPL;
		}

		IFACEMETHODIMP GetRuntimeClassName(HSTRING*) override
		{
			return E_NOTIMPL;
		}

		IFACEMETHODIMP GetTrustLevel(TrustLevel*) override
		{
			return E_NOTIMPL;
		}

		IFACEMETHODIMP GetGeometry(ID2D1Geometry** value) override
		{
			*value = _cpGeometry.get();
			(*value)->AddRef();
			return S_OK;
		}

		IFACEMETHODIMP TryGetGeometryUsingFactory(ID2D1Factory*, ID2D1Geometry**) override
		{
			return E_NOTIMPL;
		}
	};


	typedef com_ptr<GeoSource> cpCanvasGeometry;
	static bool IsRuntimeCompatible()
	{
		return false;

		if (!Windows::Foundation::Metadata::ApiInformation::IsTypePresent(L"Windows.UI.Composition.CompositionGeometricClip"))
		{
			return false;
		}
		return true;
	}

	class AnimatedVisual sealed : public Microsoft::UI::Xaml::Controls::IAnimatedVisual
	{
		com_ptr<ID2D1Factory> _d2dFactory;
		const int64_t c_durationTicks = 50050000L;
		Compositor const _c;
		ExpressionAnimation const _reusableExpressionAnimation;
		ContainerVisual _root;

		// Path 1
		CompositionColorBrush ColorBrush_AlmostDarkSlateGray_FF535353()
		{
			return _c.CreateColorBrush({ 0xFF, 0x53, 0x53, 0x53 });
		}

		// Path 1
		CompositionColorBrush ColorBrush_White()
		{
			return _c.CreateColorBrush({ 0xFF, 0xFF, 0xFF, 0xFF });
		}

		// Path 1
		//   Path 1.PathGeometry
		//     Path
		CubicBezierEasingFunction CubicBezierEasingFunction()
		{
			return _c.CreateCubicBezierEasingFunction({ 0.166999996F, 0.166999996F }, { 0.833000004F, 0.833000004F });
		}

		cpCanvasGeometry Geometry_0()
		{
			cpCanvasGeometry result;
			com_ptr<ID2D1PathGeometry> path;
			check_hresult(_d2dFactory->CreatePathGeometry(path.put()));
			com_ptr<ID2D1GeometrySink> sink;

			check_hresult(path->Open(sink.put()));
			sink->SetFillMode(D2D1_FILL_MODE_WINDING);
			sink->BeginFigure({ -90, -146 }, D2D1_FIGURE_BEGIN_FILLED);
			sink->AddLine({ 176, -148.554993F });
			sink->AddLine({ 174.445007F, 121.445F });
			sink->AddLine({ -91.5550003F, 120 });
			sink->AddLine({ -90, -146 });
			sink->EndFigure(D2D1_FIGURE_END_OPEN);
			check_hresult(sink->Close());

			result.attach(new GeoSource(path));
			return result;
		}

		cpCanvasGeometry Geometry_1()
		{
			cpCanvasGeometry result;
			com_ptr<ID2D1PathGeometry> path;
			check_hresult(_d2dFactory->CreatePathGeometry(path.put()));
			com_ptr<ID2D1GeometrySink> sink;
			check_hresult(path->Open(sink.put()));
			sink->SetFillMode(D2D1_FILL_MODE_WINDING);
			sink->BeginFigure({ -90, -146 }, D2D1_FIGURE_BEGIN_FILLED);
			sink->AddBezier({ { -90, -146 }, { 176, -148.554993F }, { 176, -148.554993F } });
			sink->AddBezier({ { 176, -148.554993F }, { 174.445007F, 121.445F }, { 174.445007F, 121.445F } });
			sink->AddBezier({ { 174.445007F, 121.445F }, { -91.5550003F, 120 }, { -91.5550003F, 120 } });
			sink->AddBezier({ { -91.5550003F, 120 }, { -90, -146 }, { -90, -146 } });
			sink->EndFigure(D2D1_FIGURE_END_OPEN);
			check_hresult(sink->Close());
			result.attach(new GeoSource(path));
			return result;
		}

		cpCanvasGeometry Geometry_2()
		{
			cpCanvasGeometry result;
			com_ptr<ID2D1PathGeometry> path;
			check_hresult(_d2dFactory->CreatePathGeometry(path.put()));
			com_ptr<ID2D1GeometrySink> sink;
			check_hresult(path->Open(sink.put()));
			sink->SetFillMode(D2D1_FILL_MODE_WINDING);
			sink->BeginFigure({ 42.2229996F, -146 }, D2D1_FIGURE_BEGIN_FILLED);
			sink->AddBezier({ { 115.248001F, -146 }, { 174.445007F, -86.1299973F }, { 174.445007F, -12.2770004F } });
			sink->AddBezier({ { 174.445007F, 61.5760002F }, { 115.248001F, 121.445F }, { 42.2229996F, 121.445F } });
			sink->AddBezier({ { -30.802F, 121.445F }, { -90, 61.5760002F }, { -90, -12.2770004F } });
			sink->AddBezier({ { -90, -86.1299973F }, { -30.802F, -146 }, { 42.2229996F, -146 } });
			sink->EndFigure(D2D1_FIGURE_END_OPEN);
			check_hresult(sink->Close());
			result.attach(new GeoSource(path));
			return result;
		}

		// Path 1
		//   Path 1.PathGeometry
		//     Path
		LinearEasingFunction LinearEasingFunction()
		{
			return _c.CreateLinearEasingFunction();
		}

		// Path 1
		// Path 1.PathGeometry
		CompositionPathGeometry PathGeometry()
		{
			auto temp = Geometry_0();
			CompositionPath compositionPath(temp.as<IGeometrySource2D>());

			auto result = _c.CreatePathGeometry(compositionPath);
			result.StartAnimation(L"Path", PathKeyFrameAnimation());
			auto controller = result.TryGetAnimationController(L"Path");
			controller.Pause();
			_reusableExpressionAnimation.ClearAllParameters();
			_reusableExpressionAnimation.Expression(L"_.Progress");
			_reusableExpressionAnimation.SetReferenceParameter(L"_", _root);
			controller.StartAnimation(L"Progress", _reusableExpressionAnimation);
			return result;
		}

		// Path 1
		//   Path 1.PathGeometry
		// Path
		PathKeyFrameAnimation PathKeyFrameAnimation()
		{
			auto result = _c.CreatePathKeyFrameAnimation();
			result.Duration(Windows::Foundation::TimeSpan{ c_durationTicks });
			result.InsertKeyFrame(0, CompositionPath(Geometry_1().as<IGeometrySource2D>()), LinearEasingFunction());
			result.InsertKeyFrame(0.239999995F, CompositionPath(Geometry_2().as<IGeometrySource2D>()), CubicBezierEasingFunction());
			return result;
		}

		// The root of the composition.
		ContainerVisual Root()
		{
			auto result = _root = _c.CreateContainerVisual();
			auto propertySet = result.Properties();
			propertySet.InsertScalar(L"Progress", 0);
			auto children = result.Children();
			children.InsertAtTop(ShapeVisual());
			return result;
		}

		ShapeVisual ShapeVisual()
		{
			auto result = _c.CreateShapeVisual();
			result.Size({ 960, 540 });
			auto shapes = result.Shapes();
			// Path 1
			shapes.Append(SpriteShape());
			return result;
		}

		// Path 1
		CompositionSpriteShape SpriteShape()
		{
			auto result = _c.CreateSpriteShape();
			result.TransformMatrix({ 1, 0, 0, 1, 480, 270 });
			result.FillBrush(ColorBrush_AlmostDarkSlateGray_FF535353());
			result.Geometry(PathGeometry());
			result.StrokeBrush(ColorBrush_White());
			result.StrokeMiterLimit(4);
			result.StrokeThickness(2);
			return result;
		}

	public:
		AnimatedVisual(const Compositor& compositor)
			: _c(compositor)
			, _reusableExpressionAnimation(compositor.CreateExpressionAnimation()),
			_root(nullptr),
			c_durationTicks(50050000L)
		{
			check_hresult(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, _d2dFactory.put()));
			Root();
		}
		virtual ~AnimatedVisual() { }

		Windows::Foundation::TimeSpan get_duration()
		{
			return Windows::Foundation::TimeSpan{ c_durationTicks };
		}

		void set_duration(Windows::Foundation::TimeSpan duration)
		{
			//TODO: 
			//c_durationTicks = duration.count();
		}

		Windows::UI::Composition::Visual RootVisual()
		{
			return _root;
		}

		Windows::Foundation::Numerics::float2 Size()
		{
			return Windows::Foundation::Numerics::float2{ 960, 540 };
		}

	};
} // end namespace


//com_ptr<Microsoft::UI::Xaml::Controls::IAnimatedVisual> AnimatedVisuals::SquareCircleMorph::TryCreateAnimatedVisual(
//    Compositor compositor,
//    com_ptr<IInspectable> diagnostics)
//{
//    diagnostics = nullptr;
//    if (!IsRuntimeCompatible())
//    {
//        return nullptr;
//    }
//    return new AnimatedVisual(compositor);
//}

#include <memory>
#include <chrono>

void AnimatedVisuals::SquareCircleMorph::TryCreateAnimatedVisual(
	Compositor const& compositor, VisualCollection const& visuals)
{
	mCompositor = compositor;

	if (!IsRuntimeCompatible())
	{
		return;
	}

	/*auto balls = new AnimatedVisual(compositor);
	thing = (void*)balls;
	visuals.InsertAtTop(balls->RootVisual());*/
}

Microsoft::UI::Xaml::Controls::IAnimatedVisual TryCreateAnimatedVisual(
	Windows::UI::Composition::Compositor compositor,
	com_ptr<IInspectable>* diagnostics) {

	diagnostics = nullptr;
	if (!IsRuntimeCompatible())
	{
		return nullptr;
	}

	AnimatedVisual vis { compositor };

	return vis.as< Microsoft::UI::Xaml::Controls::IAnimatedVisual>();
}

void AnimatedVisuals::SquareCircleMorph::Play() {
	progressAnimation = mCompositor.CreateScalarKeyFrameAnimation();
	progressAnimation.Duration(std::chrono::seconds(2));
	progressAnimation.IterationBehavior(AnimationIterationBehavior::Forever);
	progressAnimation.Direction(AnimationDirection::Alternate);
	auto linearEasing = mCompositor.CreateLinearEasingFunction();
	progressAnimation.InsertKeyFrame(0, 0, linearEasing);
	progressAnimation.InsertKeyFrame(1, 1, linearEasing);
	auto balls = (AnimatedVisual*)thing;
	auto props = balls->RootVisual().Properties();
	props.StartAnimation(L"Progress", progressAnimation);
}